/**
 * åŒºåŸŸè¦†ç›–ç‰©ç®¡ç†å™¨ v2
 *
 * äº¤äº’æµç¨‹ï¼š
 * å…¨å›½/å…¨çƒè§†å›¾ â†’ ç‚¹å‡»ä¸­å›½çœä»½æˆ–å…¶ä»–å›½å®¶ â†’ é«˜äº®
 * å†ç‚¹ä¸­å›½çœä»½ â†’ é£å…¥æ˜¾ç¤ºå¸‚çº§è¾¹ç•Œ
 * å†ç‚¹å…¶ä»–å›½å®¶ â†’ å¼¹å‡ºæ°”æ³¡ï¼ˆæ— ä¸‹é’»ï¼‰
 * ç‚¹å‡»å¸‚ â†’ æ©™è‰²é«˜äº® + æ°”æ³¡
 */
import { map, mapCommon } from '@kit.MapKit';
import { GeoJsonParser, RegionData, LatLng } from './GeoJsonParser';
import { common } from '@kit.AbilityKit';

// ==================== äº¤äº’çŠ¶æ€ ====================

export enum InteractionState {
  IDLE = 'idle',
  PROVINCE_SELECTED = 'province_selected',   // é€‰ä¸­äº†ä¸­å›½çœä»½æˆ–å…¶ä»–å›½å®¶
  CITY_VIEW = 'city_view',                   // é£å…¥ä¸­å›½æŸçœï¼Œæ˜¾ç¤ºå¸‚çº§ï¼ˆä»…ä¸­å›½ï¼‰
  CITY_SELECTED = 'city_selected'            // é€‰ä¸­äº†æŸå¸‚ï¼ˆä»…ä¸­å›½ï¼‰
}

// ==================== å›è°ƒç±»å‹ ====================

export interface RegionCallbacks {
  onProvinceSelected: (region: RegionData) => void;
  onCountrySelected: (region: RegionData) => void;
  onCitySelected: (region: RegionData) => void;
  onSelectionCleared: () => void;
}

// ==================== ç®¡ç†å™¨ ====================

export class RegionOverlayManager {
  private mapController: map.MapComponentController;
  private context: common.UIAbilityContext;

  // å½“å‰çŠ¶æ€
  private state: InteractionState = InteractionState.IDLE;

  // æ•°æ®ç¼“å­˜
  private provinceCache: RegionData[] = [];        // ä¸­å›½çœçº§
  private countryCache: RegionData[] = [];          // å…¨çƒå›½å®¶ï¼ˆä¸å«ä¸­å›½ï¼‰
  private allTopLevel: RegionData[] = [];           // çœçº§ + å›½å®¶ï¼ˆåˆå¹¶ï¼Œç”¨äºIDLEçŠ¶æ€æŸ¥æ‰¾ï¼‰
  private cityCache: Map<string, RegionData[]> = new Map();  // å¸‚çº§ç¼“å­˜

  // å½“å‰é«˜äº®çš„çœä»½/å›½å®¶
  private highlightedPolygons: map.MapPolygon[] = [];
  private highlightedRegion: RegionData | null = null;
  private highlightedIsChina: boolean = false;     // å½“å‰é«˜äº®çš„æ˜¯å¦æ˜¯ä¸­å›½çœä»½

  // å½“å‰æ˜¾ç¤ºçš„å¸‚çº§è¾¹ç•Œ
  private cityPolygons: map.MapPolygon[] = [];
  private cityRegions: RegionData[] = [];

  // å½“å‰é«˜äº®çš„å¸‚
  private highlightedCityPolygons: map.MapPolygon[] = [];
  private highlightedCity: RegionData | null = null;

  // å½“å‰é£å…¥çš„çœä»½ adcode
  private currentProvinceAdcode: string = '';

  // å›è°ƒ
  private callbacks: RegionCallbacks | null = null;

  // ä¸­å›½çš„adcode
  private readonly CHINA_ADCODE: string = '100000';
  private readonly CHINA_NAME: string = 'ä¸­å›½';

  // é¢œè‰²
  private readonly COLOR_HIGHLIGHT_STROKE: number = 0xFF4488FF;
  private readonly COLOR_HIGHLIGHT_FILL: number = 0x334488FF;
  private readonly COLOR_CITY_BORDER_STROKE: number = 0xAA4488FF;
  private readonly COLOR_CITY_BORDER_FILL: number = 0x1A4488FF;
  private readonly COLOR_CITY_HIGHLIGHT_STROKE: number = 0xFFFFB400;
  private readonly COLOR_CITY_HIGHLIGHT_FILL: number = 0x55FFB400;
  private readonly COLOR_COUNTRY_HIGHLIGHT_STROKE: number = 0xFF4488FF;
  private readonly COLOR_COUNTRY_HIGHLIGHT_FILL: number = 0x334488FF;

  constructor(mapController: map.MapComponentController, context: common.UIAbilityContext) {
    this.mapController = mapController;
    this.context = context;
  }

  setCallbacks(callbacks: RegionCallbacks): void {
    this.callbacks = callbacks;
  }

  /**
   * åˆå§‹åŒ–ï¼šåŠ è½½çœçº§ + å…¨çƒå›½å®¶æ•°æ®
   */
  async init(): Promise<void> {
    console.info('[RegionOverlay] ğŸš€ åˆå§‹åŒ–...');

    // åŠ è½½ä¸­å›½çœçº§
    this.provinceCache = await GeoJsonParser.parseFromRawFile(this.context, 'geo/china_province.json');
    console.info(`[RegionOverlay] âœ… ä¸­å›½çœçº§: ${this.provinceCache.length} ä¸ª`);

    // åŠ è½½å…¨çƒå›½å®¶
    try {
      this.countryCache = await GeoJsonParser.parseFromRawFile(this.context, 'geo/world_countries.json');
      // è¿‡æ»¤æ‰ä¸­å›½ï¼ˆå› ä¸ºä¸­å›½ç”¨çœçº§æ•°æ®ï¼‰
      this.countryCache = this.countryCache.filter((c: RegionData) => {
        return c.name !== 'China' && c.name !== 'ä¸­å›½' && c.name !== 'CN';
      });
      console.info(`[RegionOverlay] âœ… å…¨çƒå›½å®¶: ${this.countryCache.length} ä¸ª`);
    } catch (e) {
      console.warn('[RegionOverlay] âš ï¸ å…¨çƒå›½å®¶æ•°æ®åŠ è½½å¤±è´¥ï¼Œä»…ä½¿ç”¨ä¸­å›½æ•°æ®');
      this.countryCache = [];
    }

    // åˆå¹¶ï¼šçœçº§ + å›½å®¶
    this.allTopLevel = [...this.provinceCache, ...this.countryCache];
    console.info(`[RegionOverlay] âœ… é¡¶å±‚åŒºåŸŸæ€»è®¡: ${this.allTopLevel.length} ä¸ª`);
  }

  /**
   * å¤„ç†åœ°å›¾ç‚¹å‡»ï¼ˆæ ¸å¿ƒçŠ¶æ€æœºï¼‰
   */
  handleMapClick(latitude: number, longitude: number): void {
    console.info(`[RegionOverlay] ğŸ“ ç‚¹å‡» (${latitude.toFixed(4)}, ${longitude.toFixed(4)}) çŠ¶æ€: ${this.state}`);

    switch (this.state) {
      case InteractionState.IDLE:
        this.handleClickInIdle(latitude, longitude);
        break;
      case InteractionState.PROVINCE_SELECTED:
        this.handleClickInProvinceSelected(latitude, longitude);
        break;
      case InteractionState.CITY_VIEW:
        this.handleClickInCityView(latitude, longitude);
        break;
      case InteractionState.CITY_SELECTED:
        this.handleClickInCitySelected(latitude, longitude);
        break;
    }
  }

  /**
   * ç¼©æ”¾å˜åŒ–
   */
  onZoomChanged(zoom: number): void {
    if (zoom < 5 && this.state !== InteractionState.IDLE && this.state !== InteractionState.PROVINCE_SELECTED) {
      console.info('[RegionOverlay] ğŸ”™ ç¼©å°åˆ°å…¨å±€è§†å›¾ï¼Œé‡ç½®çŠ¶æ€');
      this.resetToIdle();
    }
  }

  getState(): InteractionState {
    return this.state;
  }

  // ==================== çŠ¶æ€å¤„ç† ====================

  /**
   * åˆ¤æ–­ä¸€ä¸ªåŒºåŸŸæ˜¯å¦æ˜¯ä¸­å›½çœä»½
   */
  private isChinaProvince(region: RegionData): boolean {
    return region.parent === this.CHINA_ADCODE || region.level === 'province';
  }

  /**
   * IDLEï¼šç‚¹å‡» â†’ æ‰¾çœä»½/å›½å®¶ â†’ é«˜äº®
   */
  private handleClickInIdle(lat: number, lng: number): void {
    const region = this.findRegionByPoint(lat, lng, this.allTopLevel);

    if (region) {
      const isChina = this.isChinaProvince(region);
      console.info(`[RegionOverlay] ğŸ¯ é€‰ä¸­: ${region.name} (${isChina ? 'ä¸­å›½çœä»½' : 'å›½å®¶'})`);

      this.highlightRegion(region, isChina);
      this.state = InteractionState.PROVINCE_SELECTED;

      if (this.callbacks) {
        if (isChina) {
          this.callbacks.onProvinceSelected(region);
        } else {
          this.callbacks.onCountrySelected(region);
        }
      }
    }
  }

  /**
   * PROVINCE_SELECTEDï¼š
   * - å†æ¬¡ç‚¹å‡»ä¸­å›½çœä»½ â†’ é£å…¥æ˜¾ç¤ºå¸‚çº§
   * - å†æ¬¡ç‚¹å‡»å…¶ä»–å›½å®¶ â†’ å¼¹æ°”æ³¡ï¼ˆå·²åœ¨å›è°ƒä¸­å¤„ç†ï¼‰
   * - ç‚¹å‡»å…¶ä»–åŒºåŸŸ â†’ åˆ‡æ¢é«˜äº®
   * - ç‚¹å‡»ç©ºç™½ â†’ å–æ¶ˆ
   */
  private handleClickInProvinceSelected(lat: number, lng: number): void {
    const region = this.findRegionByPoint(lat, lng, this.allTopLevel);

    if (!region) {
      this.resetToIdle();
      return;
    }

    const isChina = this.isChinaProvince(region);

    if (this.highlightedRegion && region.adcode === this.highlightedRegion.adcode) {
      // å†æ¬¡ç‚¹å‡»åŒä¸€åŒºåŸŸ
      if (isChina) {
        // ä¸­å›½çœä»½ â†’ é£å…¥ + åŠ è½½å¸‚çº§
        console.info(`[RegionOverlay] âœˆï¸ é£å…¥çœä»½: ${region.name}`);
        this.flyToProvinceAndShowCities(region);
      } else {
        // å…¶ä»–å›½å®¶ â†’ é£å…¥å±…ä¸­æ”¾å¤§ + å¼¹æ°”æ³¡ï¼ˆä¸åŠ è½½ä¸‹çº§ï¼‰
        console.info(`[RegionOverlay] âœˆï¸ é£å…¥å›½å®¶: ${region.name}`);
        this.flyToCountry(region);
      }
    } else {
      // åˆ‡æ¢åˆ°å…¶ä»–åŒºåŸŸ
      console.info(`[RegionOverlay] ğŸ”„ åˆ‡æ¢åˆ°: ${region.name}`);
      this.clearHighlight();
      this.highlightRegion(region, isChina);

      if (this.callbacks) {
        if (isChina) {
          this.callbacks.onProvinceSelected(region);
        } else {
          this.callbacks.onCountrySelected(region);
        }
      }
    }
  }

  /**
   * CITY_VIEWï¼š
   * - ç‚¹å‡»å¸‚ â†’ é«˜äº®
   * - ç‚¹å‡»å…¶ä»–çœ/å›½å®¶ â†’ åˆ‡æ¢
   */
  private handleClickInCityView(lat: number, lng: number): void {
    const city = this.findRegionByPoint(lat, lng, this.cityRegions);

    if (city) {
      console.info(`[RegionOverlay] ğŸ™ï¸ é€‰ä¸­åŸå¸‚: ${city.name}`);
      this.highlightCity(city);
      this.state = InteractionState.CITY_SELECTED;

      if (this.callbacks) {
        this.callbacks.onCitySelected(city);
      }
      return;
    }

    // æ²¡å‘½ä¸­å¸‚ â†’ æ£€æŸ¥æ˜¯å¦ç‚¹äº†å…¶ä»–çœ/å›½å®¶
    const region = this.findRegionByPoint(lat, lng, this.allTopLevel);

    if (region && region.adcode !== this.currentProvinceAdcode) {
      const isChina = this.isChinaProvince(region);
      console.info(`[RegionOverlay] ğŸ”„ ä»å¸‚çº§è§†å›¾åˆ‡æ¢åˆ°: ${region.name}`);
      this.clearCityHighlight();
      this.clearCityPolygons();
      this.cityRegions = [];
      this.currentProvinceAdcode = '';
      this.highlightRegion(region, isChina);
      this.state = InteractionState.PROVINCE_SELECTED;

      if (this.callbacks) {
        this.callbacks.onSelectionCleared();
        if (isChina) {
          this.callbacks.onProvinceSelected(region);
        } else {
          this.callbacks.onCountrySelected(region);
        }
      }
    }
  }

  /**
   * CITY_SELECTEDï¼š
   * - ç‚¹å‡»å…¶ä»–å¸‚ â†’ åˆ‡æ¢
   * - ç‚¹å‡»å…¶ä»–çœ/å›½å®¶ â†’ åˆ‡æ¢
   * - ç‚¹å‡»ç©ºç™½ â†’ å–æ¶ˆå¸‚é«˜äº®
   */
  private handleClickInCitySelected(lat: number, lng: number): void {
    const city = this.findRegionByPoint(lat, lng, this.cityRegions);

    if (city) {
      if (this.highlightedCity && city.adcode === this.highlightedCity.adcode) {
        return;
      }
      console.info(`[RegionOverlay] ğŸ”„ åˆ‡æ¢åˆ°åŸå¸‚: ${city.name}`);
      this.clearCityHighlight();
      this.highlightCity(city);

      if (this.callbacks) {
        this.callbacks.onCitySelected(city);
      }
      return;
    }

    const region = this.findRegionByPoint(lat, lng, this.allTopLevel);

    if (region && region.adcode !== this.currentProvinceAdcode) {
      const isChina = this.isChinaProvince(region);
      console.info(`[RegionOverlay] ğŸ”„ ä»åŸå¸‚è§†å›¾åˆ‡æ¢åˆ°: ${region.name}`);
      this.clearCityHighlight();
      this.clearCityPolygons();
      this.cityRegions = [];
      this.currentProvinceAdcode = '';
      this.highlightRegion(region, isChina);
      this.state = InteractionState.PROVINCE_SELECTED;

      if (this.callbacks) {
        this.callbacks.onSelectionCleared();
        if (isChina) {
          this.callbacks.onProvinceSelected(region);
        } else {
          this.callbacks.onCountrySelected(region);
        }
      }
    } else if (!region) {
      console.info('[RegionOverlay] å–æ¶ˆåŸå¸‚é€‰ä¸­');
      this.clearCityHighlight();
      this.state = InteractionState.CITY_VIEW;

      if (this.callbacks) {
        this.callbacks.onSelectionCleared();
      }
    }
  }

  // ==================== ç»˜åˆ¶æ–¹æ³• ====================

  private async highlightRegion(region: RegionData, isChina: boolean): Promise<void> {
    this.highlightedRegion = region;
    this.highlightedIsChina = isChina;

    const strokeColor = isChina ? this.COLOR_HIGHLIGHT_STROKE : this.COLOR_COUNTRY_HIGHLIGHT_STROKE;
    const fillColor = isChina ? this.COLOR_HIGHLIGHT_FILL : this.COLOR_COUNTRY_HIGHLIGHT_FILL;
    const strokeWidth = isChina ? 3 : 4.5;

    this.highlightedPolygons = await this.drawRegionPolygons(region, strokeColor, fillColor, strokeWidth);
  }

  private clearHighlight(): void {
    this.removePolygons(this.highlightedPolygons);
    this.highlightedPolygons = [];
    this.highlightedRegion = null;
    this.highlightedIsChina = false;
  }

  private async flyToProvinceAndShowCities(province: RegionData): Promise<void> {
    this.clearHighlight();

    const targetZoom = 7;
    try {
      const cameraUpdate = map.newCameraPosition({
        target: {
          latitude: province.center[1],
          longitude: province.center[0]
        },
        zoom: targetZoom
      });
      this.mapController.animateCamera(cameraUpdate, 800);
    } catch (e) {
      console.error('[RegionOverlay] âŒ ç›¸æœºåŠ¨ç”»å¤±è´¥', e);
      try {
        this.mapController.moveCamera(map.newCameraPosition({
          target: {
            latitude: province.center[1],
            longitude: province.center[0]
          },
          zoom: targetZoom
        }));
      } catch (e2) {
        console.error('[RegionOverlay] âŒ ç›¸æœºç§»åŠ¨ä¹Ÿå¤±è´¥', e2);
      }
    }

    this.currentProvinceAdcode = province.adcode;
    let cities = this.cityCache.get(province.adcode);

    if (!cities) {
      console.info(`[RegionOverlay] ğŸŒ åŠ è½½ ${province.name} å¸‚çº§æ•°æ®...`);
      cities = await GeoJsonParser.parseFromNetwork(province.adcode);
      if (cities.length > 0) {
        this.cityCache.set(province.adcode, cities);
      }
    }

    if (cities && cities.length > 0) {
      this.cityRegions = cities;
      await this.drawCityBorders(cities);
      this.state = InteractionState.CITY_VIEW;
      console.info(`[RegionOverlay] âœ… æ˜¾ç¤º ${cities.length} ä¸ªå¸‚çº§è¾¹ç•Œ`);
    }
  }

  /**
   * é£å…¥å›½å®¶ï¼šå±…ä¸­æ”¾å¤§ + å¼¹æ°”æ³¡ï¼ˆä¸åŠ è½½ä¸‹çº§è¾¹ç•Œï¼‰
   */
  private async flyToCountry(country: RegionData): Promise<void> {
    const box = country.boundingBox;
    const latSpan = box.maxLat - box.minLat;
    const lngSpan = box.maxLng - box.minLng;
    const maxSpan = Math.max(latSpan, lngSpan);

    // ç¼©æ”¾çº§åˆ«è°ƒå°ï¼Œä¸éœ€è¦æ”¾å¤ªå¤§
    let targetZoom = 4;
    if (maxSpan > 20) {
      targetZoom = 5;
    } else {
      targetZoom = 6;
    }

    try {
      const cameraUpdate = map.newCameraPosition({
        target: {
          latitude: country.center[1],
          longitude: country.center[0]
        },
        zoom: targetZoom
      });
      this.mapController.animateCamera(cameraUpdate, 800);
    } catch (e) {
      console.error('[RegionOverlay] âŒ ç›¸æœºåŠ¨ç”»å¤±è´¥', e);
      try {
        this.mapController.moveCamera(map.newCameraPosition({
          target: {
            latitude: country.center[1],
            longitude: country.center[0]
          },
          zoom: targetZoom
        }));
      } catch (e2) {
        console.error('[RegionOverlay] âŒ ç›¸æœºç§»åŠ¨ä¹Ÿå¤±è´¥', e2);
      }
    }

    if (this.callbacks) {
      this.callbacks.onCountrySelected(country);
    }
  }

  private async drawCityBorders(cities: RegionData[]): Promise<void> {
    this.clearCityPolygons();

    for (let i = 0; i < cities.length; i++) {
      const polygons = await this.drawRegionPolygons(
        cities[i],
        this.COLOR_CITY_BORDER_STROKE,
        this.COLOR_CITY_BORDER_FILL,
        2
      );
      for (let j = 0; j < polygons.length; j++) {
        this.cityPolygons.push(polygons[j]);
      }
    }
  }

  private async highlightCity(city: RegionData): Promise<void> {
    this.highlightedCity = city;
    this.highlightedCityPolygons = await this.drawRegionPolygons(
      city,
      this.COLOR_CITY_HIGHLIGHT_STROKE,
      this.COLOR_CITY_HIGHLIGHT_FILL,
      4
    );
  }

  private clearCityHighlight(): void {
    this.removePolygons(this.highlightedCityPolygons);
    this.highlightedCityPolygons = [];
    this.highlightedCity = null;
  }

  private clearCityPolygons(): void {
    this.removePolygons(this.cityPolygons);
    this.cityPolygons = [];
  }

  private resetToIdle(): void {
    this.clearCityHighlight();
    this.clearCityPolygons();
    this.clearHighlight();
    this.cityRegions = [];
    this.currentProvinceAdcode = '';
    this.state = InteractionState.IDLE;

    if (this.callbacks) {
      this.callbacks.onSelectionCleared();
    }
    console.info('[RegionOverlay] ğŸ”„ é‡ç½®åˆ°IDLEçŠ¶æ€');
  }

  // ==================== åº•å±‚å·¥å…· ====================

  private async drawRegionPolygons(
    region: RegionData,
    strokeColor: number,
    fillColor: number,
    strokeWidth: number
  ): Promise<map.MapPolygon[]> {

    const polygons: map.MapPolygon[] = [];

    for (let j = 0; j < region.boundaries.length; j++) {
      const boundary = region.boundaries[j];
      if (boundary.length < 3) continue;

      const points: mapCommon.LatLng[] = [];
      for (let k = 0; k < boundary.length; k++) {
        points.push({
          latitude: boundary[k].latitude,
          longitude: boundary[k].longitude
        });
      }

      try {
        const polygonOptions: mapCommon.MapPolygonOptions = {
          points: points,
          clickable: false,
          strokeColor: strokeColor,
          fillColor: fillColor,
          strokeWidth: strokeWidth
        };

        const polygon: map.MapPolygon = await this.mapController.addPolygon(polygonOptions);
        polygons.push(polygon);
      } catch (error) {
        console.error(`[RegionOverlay] âŒ ç»˜åˆ¶Polygonå¤±è´¥: ${region.name}`, error);
      }
    }

    return polygons;
  }

  private removePolygons(polygons: map.MapPolygon[]): void {
    for (let i = 0; i < polygons.length; i++) {
      try {
        polygons[i].remove();
      } catch (e) {
        // å¿½ç•¥
      }
    }
  }

  private findRegionByPoint(lat: number, lng: number, regions: RegionData[]): RegionData | null {
    for (let i = 0; i < regions.length; i++) {
      const region = regions[i];
      const box = region.boundingBox;

      if (lat < box.minLat || lat > box.maxLat || lng < box.minLng || lng > box.maxLng) {
        continue;
      }

      for (let j = 0; j < region.boundaries.length; j++) {
        if (this.isPointInPolygon(lat, lng, region.boundaries[j])) {
          return region;
        }
      }
    }
    return null;
  }

  private isPointInPolygon(lat: number, lng: number, polygon: LatLng[]): boolean {
    let inside = false;
    const n = polygon.length;
    let j = n - 1;

    for (let i = 0; i < n; i++) {
      const yi = polygon[i].latitude;
      const xi = polygon[i].longitude;
      const yj = polygon[j].latitude;
      const xj = polygon[j].longitude;

      if (((yi > lat) !== (yj > lat)) &&
        (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
        inside = !inside;
      }
      j = i;
    }
    return inside;
  }
}