/**
 * GeoJSON è§£æå·¥å…·ç±»
 * æ”¯æŒæœ¬åœ°rawfileå’Œç½‘ç»œåœ¨çº¿åŠ è½½
 */
import { common } from '@kit.AbilityKit';
import { util } from '@kit.ArkTS';
import { http } from '@kit.NetworkKit';

// ==================== æ•°æ®ç»“æ„å®šä¹‰ ====================

export interface RegionData {
  adcode: string;
  name: string;
  center: number[];
  level: string;
  parent: string;
  boundaries: LatLng[][];
  boundingBox: BoundingBox;
}

export interface LatLng {
  latitude: number;
  longitude: number;
}

export interface BoundingBox {
  minLat: number;
  maxLat: number;
  minLng: number;
  maxLng: number;
}

// ==================== GeoJSON åŸå§‹ç±»å‹ ====================

interface GeoJsonFeatureCollection {
  type: string;
  features: GeoJsonFeature[];
}

interface GeoJsonFeature {
  type: string;
  properties: GeoJsonProperties;
  geometry: GeoJsonGeometry;
}

interface GeoJsonProperties {
  adcode: number | null;
  name: string;
  center: number[] | null;
  centroid: number[] | null;
  level: string | null;
  parent: GeoJsonParent | null;
  childrenNum: number | null;
  subFeatureIndex: number | null;
  acroutes: number[] | null;
}

interface GeoJsonParent {
  adcode: number;
}

interface GeoJsonGeometry {
  type: string;
  coordinates: number[][][] | number[][][][];
}

// ==================== è§£æå™¨ ====================

export class GeoJsonParser {

  /**
   * ä» rawfile è¯»å–å¹¶è§£æ GeoJSONï¼ˆæœ¬åœ°æ–‡ä»¶ï¼‰
   */
  static async parseFromRawFile(context: common.UIAbilityContext, filePath: string): Promise<RegionData[]> {
    try {
      const resourceManager = context.resourceManager;
      const fileData: Uint8Array = await resourceManager.getRawFileContent(filePath);

      console.info(`[GeoJsonParser] ğŸ“ æ–‡ä»¶å¤§å°: ${fileData.length} å­—èŠ‚`);

      const textDecoder = util.TextDecoder.create('utf-8');
      const jsonString = textDecoder.decodeWithStream(fileData);

      return GeoJsonParser.parseJsonString(jsonString, filePath);

    } catch (error) {
      console.error(`[GeoJsonParser] âŒ æœ¬åœ°è§£æå¤±è´¥: ${filePath}`, JSON.stringify(error));
      return [];
    }
  }

  /**
   * ä»ç½‘ç»œåŠ è½½å¹¶è§£æ GeoJSONï¼ˆåŠ¨æ€åŠ è½½ä¸‹çº§åŒºåŸŸï¼‰
   * @param adcode è¡Œæ”¿åŒºåˆ’ä»£ç ï¼Œå¦‚ "440000"ï¼ˆå¹¿ä¸œçœï¼‰
   */
  static async parseFromNetwork(adcode: string): Promise<RegionData[]> {
    const url = `https://geo.datav.aliyun.com/areas_v3/bound/${adcode}_full.json`;

    try {
      console.info(`[GeoJsonParser] ğŸŒ è¯·æ±‚: ${url}`);

      const httpRequest = http.createHttp();
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json'
        },
        connectTimeout: 10000,
        readTimeout: 15000
      });

      if (response.responseCode !== 200) {
        console.error(`[GeoJsonParser] âŒ HTTP ${response.responseCode}`);
        httpRequest.destroy();
        return [];
      }

      const jsonString = response.result as string;
      httpRequest.destroy();

      return GeoJsonParser.parseJsonString(jsonString, adcode);

    } catch (error) {
      console.error(`[GeoJsonParser] âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥: ${adcode}`, JSON.stringify(error));
      return [];
    }
  }

  /**
   * è§£æ JSON å­—ç¬¦ä¸²ä¸º RegionData æ•°ç»„ï¼ˆå…±ç”¨é€»è¾‘ï¼‰
   */
  private static parseJsonString(jsonString: string, source: string): RegionData[] {
    const geoJson: GeoJsonFeatureCollection = JSON.parse(jsonString) as GeoJsonFeatureCollection;

    console.info(`[GeoJsonParser] ğŸ“Š ${source} featuresæ•°é‡: ${geoJson.features ? geoJson.features.length : 0}`);

    const regions: RegionData[] = [];
    for (let i = 0; i < geoJson.features.length; i++) {
      const region = GeoJsonParser.parseFeature(geoJson.features[i]);
      if (region !== null) {
        regions.push(region);
      }
    }

    console.info(`[GeoJsonParser] âœ… è§£æå®Œæˆ: ${source}, å…± ${regions.length} ä¸ªåŒºåŸŸ`);
    return regions;
  }

  private static parseFeature(feature: GeoJsonFeature): RegionData | null {
    try {
      const props = feature.properties;
      const geometry = feature.geometry;

      const boundaries: LatLng[][] = GeoJsonParser.parseGeometry(geometry);

      if (boundaries.length === 0) {
        return null;
      }

      const boundingBox = GeoJsonParser.calculateBoundingBox(boundaries);

      // å…¼å®¹ä¸åŒæ•°æ®æºçš„å­—æ®µ
      const adcode = (props.adcode !== null && props.adcode !== undefined)
        ? props.adcode.toString()
        : (props.name || '');

      const center = props.center || props.centroid || GeoJsonParser.calculateCenter(boundaries);

      const region: RegionData = {
        adcode: adcode,
        name: props.name || '',
        center: center,
        level: props.level || 'country',
        parent: (props.parent !== null && props.parent !== undefined &&
          props.parent.adcode !== null && props.parent.adcode !== undefined)
          ? props.parent.adcode.toString() : '',
        boundaries: boundaries,
        boundingBox: boundingBox
      };

      return region;

    } catch (error) {
      console.error(`[GeoJsonParser] è§£æFeatureå¤±è´¥`, error);
      return null;
    }
  }

  /**
   * æ ¹æ®è¾¹ç•Œè®¡ç®—ä¸­å¿ƒç‚¹
   */
  private static calculateCenter(boundaries: LatLng[][]): number[] {
    let totalLat = 0;
    let totalLng = 0;
    let count = 0;

    for (let i = 0; i < boundaries.length; i++) {
      for (let j = 0; j < boundaries[i].length; j++) {
        totalLng += boundaries[i][j].longitude;
        totalLat += boundaries[i][j].latitude;
        count++;
      }
    }

    if (count === 0) return [0, 0];
    return [totalLng / count, totalLat / count];  // [ç»åº¦, çº¬åº¦]
  }

  private static parseGeometry(geometry: GeoJsonGeometry): LatLng[][] {
    const result: LatLng[][] = [];

    if (geometry.type === 'Polygon') {
      const coords = geometry.coordinates as number[][][];
      for (let ring = 0; ring < coords.length; ring++) {
        const points: LatLng[] = [];
        for (let i = 0; i < coords[ring].length; i++) {
          points.push({
            longitude: coords[ring][i][0],
            latitude: coords[ring][i][1]
          });
        }
        result.push(points);
      }

    } else if (geometry.type === 'MultiPolygon') {
      const multiCoords = geometry.coordinates as number[][][][];
      for (let p = 0; p < multiCoords.length; p++) {
        for (let ring = 0; ring < multiCoords[p].length; ring++) {
          const points: LatLng[] = [];
          for (let i = 0; i < multiCoords[p][ring].length; i++) {
            points.push({
              longitude: multiCoords[p][ring][i][0],
              latitude: multiCoords[p][ring][i][1]
            });
          }
          result.push(points);
        }
      }
    }

    return result;
  }

  private static calculateBoundingBox(boundaries: LatLng[][]): BoundingBox {
    let minLat = 90;
    let maxLat = -90;
    let minLng = 180;
    let maxLng = -180;

    for (let i = 0; i < boundaries.length; i++) {
      for (let j = 0; j < boundaries[i].length; j++) {
        const point = boundaries[i][j];
        if (point.latitude < minLat) minLat = point.latitude;
        if (point.latitude > maxLat) maxLat = point.latitude;
        if (point.longitude < minLng) minLng = point.longitude;
        if (point.longitude > maxLng) maxLng = point.longitude;
      }
    }

    return { minLat, maxLat, minLng, maxLng };
  }
}